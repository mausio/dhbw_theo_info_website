{
  "navigation": {
    "imprint": "Impressum",
    "home": "Startseite",
    "sorting": "Sortieralgorithmen",
    "search": "Suche",
    "graphs": "Graphen",
    "coding": "Coding",
    "account" : "Account",
    "radix": "Radix",
    "merge": "Merge",
    "bucket": "Bucket",
    "counting": "Counting",
    "heap": "Heap",
    "quick": "Quick",
    "insertion": "Insertion",
    "reset": "Demo-Fortschritt zur√ºcksetzen"
  },
  "home": {
    "title": "ALGO",
    "subtitle": "Willkommen zu den Aufgaben der Algorithmen!",
    "noLoginRequired": "Es ist nicht notwendig, sich anzumelden, um die √úbungen zu machen.",
    "bonusNote": "‚ö†Ô∏è Wenn Sie jedoch den Vorlesungsbonus erhalten m√∂chten, m√ºssen Sie sich anmelden und abgeschlossene Aufgaben einreichen.",
    "tipsTitle": "üí° Tipps:",
    "tipSubmit": "Vergessen Sie nach erfolgreichem Abschluss einer Aufgabe nicht, auf die Schaltfl√§che \"Absenden\" zu klicken! üîî",
    "tipBigScreen": "Es ist sch√∂ner, gro√üe Bildschirme zu verwenden ü§ì",
    "loginInstruction": "Verwenden Sie zur Anmeldung die Informationen, die Ihr Dozent Ihnen gegeben hat. üìú",
    "bonusInstruction": "Um den Bonus zu erhalten, schlie√üen Sie alle Aufgaben vor der Pr√ºfung ab!!! ‚è≥",
    "fun": "Viel Spa√ü! üéâ",
    "story": {
      "welcomeTitle": "Willkommen zu deinem Algorithmen-Abenteuer! üöÄ",
      "meetAlex": "Hallo! Ich bin Alex - Dein Algorithmen-Guide",
      "intro": "Hallo! üëã Ich bin Alex, ein Student wie du, und ich werde dich durch die spannende Welt der Algorithmen f√ºhren. Vor nicht allzu langer Zeit war ich selbst noch verwirrt von diesen Konzepten. Aber dann entdeckte ich, dass das Lernen von Algorithmen ein fantastisches Abenteuer sein kann, bei dem jeder Algorithmus seine eigene einzigartige Superkraft hat!",
      "exerciseInfo": "Das Beste daran? Du kannst sofort mit dieser Reise beginnen - keine Anmeldung erforderlich! Wenn du jedoch den Vorlesungsbonus erhalten m√∂chtest (und glaub mir, es lohnt sich! üåü), melde dich an und reiche deine abgeschlossenen Aufgaben ein.",
      "meetCharacters": "Lass mich dir unsere Algorithmen-Helden vorstellen:",
      "quickSort": "Quick Sort - Der Sprinter, der teilt und herrscht",
      "mergeSort": "Merge Sort - Der Meister des perfekten Zusammenf√ºgens",
      "heapSort": "Heap Sort - Der organisierte Bibliothekar der Daten",
      "insertionSort": "Insertion Sort - Der sorgf√§ltige Kartengeber",
      "bucketSort": "Bucket Sort - Der Sortierhut unserer Algorithmenwelt",
      "radixSort": "Radix Sort - Das stellenweise Genie",
      "countingSort": "Counting Sort - Der Experte f√ºr Z√§hlen und Ordnen",
      "importantNotes": "Bevor wir unser Abenteuer beginnen, hier einige schnelle Tipps von einem Mitreisenden:",
      "loginTip": "üìú Zur Anmeldung verwende die Informationen deines Dozenten",
      "examTip": "‚è≥ Schlie√üe alle Aufgaben vor der Pr√ºfung ab, um deinen Bonus zu sichern",
      "submitTip": "üîî Vergiss nicht, nach jeder abgeschlossenen Aufgabe auf 'Absenden' zu klicken",
      "screenTip": "ü§ì Nutze einen gro√üen Bildschirm f√ºr das beste Erlebnis",
      "callToAction": "Bereit, mit mir auf dieses Abenteuer zu gehen? Jeder Algorithmus hat seine eigene Geschichte zu erz√§hlen, und gemeinsam werden wir ihre Geheimnisse l√ºften! Verfolge deinen Fortschritt in der Bestenliste oben und verdiene dir dein Algorithmen-Meister-Abzeichen! üèÜ",
      "funWish": "Lass uns das Lernen von Algorithmen spa√üig gestalten! üéâ"
    }
  },
  "sorting": {
    "insertion": {
      "description": "Insertion Sort baut ein sortiertes Array auf, indem es ein Element nach dem anderen vergleicht und an die richtige Position einf√ºgt, √§hnlich wie beim Sortieren von Spielkarten in der Hand.",
      "process": "Prozess:",
      "steps": {
        "1": "Beginne mit dem ersten Element als sortiert",
        "2": "Nimm das n√§chste Element und vergleiche es mit allen Elementen im sortierten Bereich",
        "3": "Verschiebe gr√∂√üere Elemente nach rechts, um Platz zu schaffen",
        "4": "F√ºge das Element an der richtigen Position ein",
        "5": "Wiederhole Schritte 2-4, bis alle Elemente sortiert sind"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "animation": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Mische!",
        "sortingCompleted": "Sortierung abgeschlossen!",
        "key": "A[{{index}}] = Schl√ºssel = {{value}}",
        "comparison": "A[{{index}}] = {{value}} ist {{comparison}} als der Schl√ºssel(={{key}})",
        "smaller": "kleiner",
        "greater": "gr√∂√üer",
        "propagating": "propagiere vorw√§rts...",
        "placingKey": "platziere den Schl√ºssel(={{key}}) bei A[{{index}}]",
        "nextKey": "weiter zum n√§chsten Schl√ºssel..."
      },
      "task": {
        "title": "Aufgabe 1 Schrittweise Wert",
        "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays A nach jeder for-Schleife ein.",
        "inputArray": "Eingabearray:",
        "submit": "Einreichen?",
        "alreadyCompleted": "Sie haben diese Aufgabe bereits abgeschlossen!",
        "pointsEarned": "Sie haben {{points}} Punkte verdient!",
        "tryAgain": "Nochmal versuchen"
      },
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die Zeitkomplexit√§t von Insertion Sort im besten Fall?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Welche der folgenden Aussagen √ºber Insertion Sort ist richtig?",
            "answers": [
              "Es ben√∂tigt zus√§tzlichen Speicher proportional zur Eingabegr√∂√üe",
              "Es ist nicht geeignet f√ºr kleine Datenmengen",
              "Es funktioniert gut mit bereits sortierten Daten",
              "Es braucht immer die gleiche Zeit unabh√§ngig von der Eingabe"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Wie ist die Speicherkomplexit√§t von Insertion Sort?",
            "answers": [
              "O(n)",
              "O(log n)",
              "O(n¬≤)",
              "O(1)"
            ],
            "correctAnswer": 3
          },
          {
            "question": "Was macht Insertion Sort effizient f√ºr kleine Datenmengen?",
            "answers": [
              "Es verwendet komplexe Datenstrukturen",
              "Es hat eine einfache Implementierung und geringen Overhead",
              "Es ben√∂tigt zus√§tzlichen Speicher",
              "Es verwendet Rekursion"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Wie verh√§lt sich Insertion Sort bei fast sortierten Arrays?",
            "answers": [
              "Schlecht, ben√∂tigt viele Vertauschungen",
              "Gleich wie bei zuf√§lligen Daten",
              "Sehr effizient, n√§hert sich O(n)",
              "Kein Unterschied zum schlechtesten Fall"
            ],
            "correctAnswer": 2
          }
        ]
      }
    },
    "animation": {
      "common": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Array wird gemischt...",
        "shufflingFinished": "Array gemischt! Bereit zum Sortieren.",
        "sortingComplete": "Sortierung abgeschlossen!",
        "speedSlider": "Animationsgeschwindigkeit",
        "buttons": {
          "shuffle": "Mischen",
          "sort": "Sortieren",
          "step": "Schritt",
          "manual": "Manuell",
          "continue": "Fortsetzen",
          "pause": "Pause",
          "animate": "Animieren"
        }
      }
    },
    "heap": {
      "description": "Heap Sort verwendet eine bin√§re Heap-Datenstruktur und sortiert Elemente durch wiederholtes Extrahieren des maximalen Elements und Neuaufbau des Heaps.",
      "process": "Prozess:",
      "steps": {
        "1": "Erstelle einen Max-Heap aus dem Eingabe-Array",
        "2": "Tausche die Wurzel (maximales Element) mit dem letzten Element des Heaps",
        "3": "Entferne das letzte Element aus dem Heap (f√ºge es zum sortierten Bereich hinzu)",
        "4": "Heapifiziere das Wurzelelement, um die Max-Heap-Eigenschaft zu erhalten",
        "5": "Wiederhole Schritte 2-4, bis der Heap leer ist"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(1)",
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die Zeitkomplexit√§t von Heap Sort in allen F√§llen (beste, durchschnittliche und schlechteste)?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Welche Datenstruktur wird in Heap Sort verwendet?",
            "answers": [
              "Verkettete Liste",
              "Stack",
              "Bin√§rer Heap",
              "Hash-Tabelle"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Wie ist die Speicherkomplexit√§t von Heap Sort?",
            "answers": [
              "O(n)",
              "O(log n)",
              "O(n¬≤)",
              "O(1)"
            ],
            "correctAnswer": 3
          },
          {
            "question": "Welche Eigenschaft muss in einem Max-Heap erhalten bleiben?",
            "answers": [
              "Elternknoten sind kleiner als Kindknoten",
              "Alle Ebenen m√ºssen vollst√§ndig sein",
              "Elternknoten sind gr√∂√üer als Kindknoten",
              "Knoten m√ºssen ausbalanciert sein"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Ist Heap Sort stabil?",
            "answers": [
              "Ja, immer",
              "Nein, es kann die relative Reihenfolge gleicher Elemente √§ndern",
              "H√§ngt von der Implementierung ab",
              "Nur bei kleinen Arrays"
            ],
            "correctAnswer": 1
          }
        ]
      },
      "animation": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Mische!",
        "shufflingFinished": "Mischen beendet. Starte Sortierung!",
        "sortingComplete": "Sortierung abgeschlossen!",
        "outOfBounds": "au√üerhalb des Bereichs!",
        "noChildren": "hat keine Kinder",
        "lookingAtNode": "Betrachte Wert {{value}}",
        "comparingWithChildren": "Vergleiche Wert {{parentValue}} mit seinen Kindern",
        "swappingNodes": "Tausche Werte {{value1}} und {{value2}}",
        "heapified": "Teilbaum bei Wert {{value}} heapifiziert",
        "extractingMax": "Extrahiere maximales Element aus dem Heap",
        "placingExtracted": "Platziere Wert {{value}} in sortierter Position",
        "buttons": {
          "shuffle": "Mischen",
          "sort": "Sortieren",
          "step": "Schritt",
          "manual": "Manuell",
          "continue": "Fortsetzen",
          "pause": "Pause",
          "animate": "Animieren"
        }
      }
    },
    "counting": {
      "description": "Counting Sort ist ein nicht-vergleichender Sortieralgorithmus, der durch Z√§hlen der Vorkommen jedes Elements und deren Platzierung an der richtigen Position funktioniert.",
      "process": "Prozess:",
      "steps": {
        "1": "Finde den Wertebereich des Eingabe-Arrays",
        "2": "Erstelle ein Z√§hl-Array und z√§hle jedes Element",
        "3": "Modifiziere das Z√§hl-Array, um die tats√§chlichen Positionen zu enthalten",
        "4": "Baue das Ausgabe-Array auf",
        "5": "Kopiere das Ausgabe-Array zur√ºck in das urspr√ºngliche Array"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n+k)",
      "averageTime": "O(n+k)",
      "worstTime": "O(n+k)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "countingPhase": "Starte Z√§hlphase...",
        "step1": "Erstelle Z√§hl-Array...",
        "accessingValue": "Greife auf Wert bei Index {{index}} zu: {{value}}",
        "selectingArray": "W√§hle Z√§hl-Array bei Index {{index}}",
        "incrementingCount": "Erh√∂he Z√§hler bei Index {{index}} auf {{count}}",
        "summingTotals": "Berechne Summen im Z√§hl-Array...",
        "calculatingSum": "Berechne Summe bei Index {{index}} mit vorherigem Index {{prevIndex}}",
        "sumResult": "Summe bei Index {{index}} ist {{sum}}",
        "placingElements": "Platziere Elemente in sortierte Positionen...",
        "selectingElement": "W√§hle Element bei Index {{index}}",
        "selectingCount": "Pr√ºfe Z√§hler bei Index {{index}}",
        "selectingPosition": "Position gefunden bei Index {{index}}",
        "placingElement": "Verschiebe Element von Index {{sourceIndex}} zu Position {{targetIndex}}",
        "decrementingCount": "Verringere Z√§hler bei Index {{index}}",
        "done": "Fertig!",
        "sortingComplete": "Array sortiert!"
      },
      "task": {
        "title": "Aufgabe 1: Bestimmung der Counting Arrays",
        "description": "F√ºllen Sie die Counting Arrays aus und konstruieren Sie das sortierte Array Schritt f√ºr Schritt.",
        "inputArray": "Eingabearray:",
        "arrays": {
          "counting": "Z√§hlarray",
          "accumulating": "Akkumulierendes Array",
          "sortable": "Sortierbares Array",
          "unsorted": "Unsortiertes Array"
        },
        "submit": "Absenden",
        "alreadyCompleted": "Sie haben diese Aufgabe bereits abgeschlossen und {{points}} Punkte erhalten!",
        "pointsEarned": "Gl√ºckwunsch! Sie haben {{points}} Punkte f√ºr diese Aufgabe erhalten!"
      },
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die Zeitkomplexit√§t von Counting Sort?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n+k)",
              "O(n)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Was ist eine Einschr√§nkung von Counting Sort?",
            "answers": [
              "Kann nur positive Ganzzahlen sortieren",
              "Ben√∂tigt viel Speicher f√ºr gro√üe Wertebereiche",
              "Funktioniert nur mit sortierten Arrays",
              "Kann keine Duplikate verarbeiten"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Ist Counting Sort ein vergleichsbasierter Sortieralgorithmus?",
            "answers": [
              "Ja, es vergleicht Elemente direkt",
              "Nein, es verwendet das Z√§hlen von Elementen",
              "Manchmal, abh√§ngig von der Eingabe",
              "Ja, aber nur f√ºr kleine Arrays"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Was macht Counting Sort effizient f√ºr Ganzzahlen?",
            "answers": [
              "Es verwendet Vergleiche effizient",
              "Es verwendet Teile und Herrsche",
              "Es z√§hlt Vorkommen statt zu vergleichen",
              "Es verwendet einen Bin√§rbaum"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Was bestimmt den zus√§tzlichen Speicherbedarf bei Counting Sort?",
            "answers": [
              "Die Gr√∂√üe des Eingabe-Arrays",
              "Der Wertebereich der Eingabewerte (k)",
              "Die Anzahl der eindeutigen Elemente",
              "Die Sortierreihenfolge"
            ],
            "correctAnswer": 1
          }
        ]
      }
    },
    "radix": {
      "description": "Radix Sort ist ein nicht-vergleichender Sortieralgorithmus, der Zahlen sortiert, indem jede Ziffer von der am wenigsten signifikanten zur am meisten signifikanten verarbeitet wird.",
      "process": "Prozess:",
      "steps": {
        "1": "Beginne mit der rechten Ziffer",
        "2": "Sortiere Zahlen basierend auf der aktuellen Ziffer",
        "3": "Gehe zur n√§chsten Ziffer links",
        "4": "Wiederhole, bis alle Ziffern verarbeitet sind"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(nk)",
      "averageTime": "O(nk)",
      "worstTime": "O(nk)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Mische!",
        "shufflingFinished": "Mischen beendet. Starte Sortierung!",
        "sortingComplete": "Sortierung abgeschlossen!",
        "selectingDigit": "W√§hle Ziffer Nr. {{index}}",
        "sorting": "Sortiere([{{digits}}])",
        "finishedDigit": "Sortierung basierend auf Ziffer Nr.{{index}} abgeschlossen"
      },
      "task": {
        "numbers": {
          "title": "Aufgabe 1 Schrittweise A Wert, Zahlen",
          "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays A nach jeder for-Schleife ein.",
          "inputArray": "Eingabearray:",
          "alreadyCompleted": "Sie haben diese Aufgabe bereits abgeschlossen und {{points}} Punkte erhalten!",
          "pointsEarned": "Gl√ºckwunsch! Sie haben {{points}} Punkte f√ºr diese Aufgabe erhalten!"
        },
        "words": {
          "title": "Aufgabe 2 Schrittweise B Wert, W√∂rter",
          "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays B nach jeder for-Schleife ein.",
          "inputArray": "Eingabearray:",
          "alreadyCompleted": "Sie haben diese Aufgabe bereits abgeschlossen und {{points}} Punkte erhalten!",
          "pointsEarned": "Gl√ºckwunsch! Sie haben {{points}} Punkte f√ºr diese Aufgabe erhalten!"
        },
        "iteration": {
          "afterIteration": "Nach Iteration Nr",
          "reset": "Zur√ºck",
          "check": "Pr√ºfen"
        }
      },
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die Zeitkomplexit√§t von Radix Sort?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(nk)",
              "O(n+k)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Was unterscheidet Radix Sort von vergleichsbasierten Sortieralgorithmen?",
            "answers": [
              "Es verwendet ein Pivot-Element",
              "Es vergleicht Elemente nicht direkt",
              "Es verwendet eine Heap-Struktur",
              "Es erfordert sortierte Eingaben"
            ],
            "correctAnswer": 1
          },
          {
            "question": "In welcher Reihenfolge verarbeitet Radix Sort die Ziffern?",
            "answers": [
              "Von der h√∂chstwertigen zur niedrigstwertigen",
              "Von der niedrigstwertigen zur h√∂chstwertigen",
              "In zuf√§lliger Reihenfolge",
              "Von der Mitte zu den Enden"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Welche Art von Stabilit√§t ist entscheidend f√ºr die korrekte Funktionsweise von Radix Sort?",
            "answers": [
              "Speicherstabilit√§t",
              "Sortierstabilit√§t",
              "Zeitstabilit√§t",
              "Raumstabilit√§t"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Was bestimmt die Anzahl der Durchl√§ufe bei Radix Sort?",
            "answers": [
              "Array-Gr√∂√üe",
              "Anzahl eindeutiger Elemente",
              "Anzahl der Stellen in der gr√∂√üten Zahl",
              "Speicherbeschr√§nkungen"
            ],
            "correctAnswer": 2
          }
        ]
      }
    },
    "merge": {
      "description": "Merge Sort ist ein Divide-and-Conquer-Algorithmus, der das Array rekursiv in kleinere Teilarrays aufteilt, diese sortiert und dann wieder zusammenf√ºhrt.",
      "process": "Prozess:",
      "steps": {
        "1": "Teile das Array in zwei H√§lften",
        "2": "Sortiere die linke und rechte H√§lfte rekursiv",
        "3": "F√ºhre die sortierten H√§lften wieder zusammen",
        "4": "Fahre fort, bis das gesamte Array sortiert ist"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(n)",
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die Zeitkomplexit√§t von Merge Sort in allen F√§llen (beste, durchschnittliche und schlechteste)?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Wie ist die Speicherkomplexit√§t von Merge Sort?",
            "answers": [
              "O(n)",
              "O(log n)",
              "O(n¬≤)",
              "O(1)"
            ],
            "correctAnswer": 0
          },
          {
            "question": "Welches algorithmische Paradigma verwendet Merge Sort?",
            "answers": [
              "Greedy-Algorithmus",
              "Dynamische Programmierung",
              "Teile und Herrsche",
              "Backtracking"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Was ist ein wichtiger Vorteil von Merge Sort?",
            "answers": [
              "In-Place-Sortierung",
              "Geringer Speicherverbrauch",
              "Garantierte O(n log n) Leistung",
              "Einfache Implementierung"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Was ist ein Nachteil von Merge Sort?",
            "answers": [
              "Hohe Zeitkomplexit√§t",
              "Ben√∂tigt zus√§tzlichen Speicher O(n)",
              "Nicht stabil",
              "Kann gro√üe Datens√§tze nicht verarbeiten"
            ],
            "correctAnswer": 1
          }
        ]
      },
      "animation": {
        "lookingAtRange": "Betrachte Bereich von Index {{start}} bis {{end}}",
        "findingMiddle": "Finde Mittelpunkt bei Index {{middle}}",
        "dividing": "Teile in linken Teil ({{leftStart}}-{{leftEnd}}) und rechten ({{rightStart}}-{{rightEnd}}) Teil",
        "sortingLeft": "Sortiere linken Teil von Index {{start}} bis {{end}}",
        "sortingRight": "Sortiere rechten Teil von Index {{start}} bis {{end}}",
        "mergingRanges": "F√ºhre Bereiche von {{leftStart}}-{{leftEnd}} und {{rightStart}}-{{rightEnd}} zusammen",
        "preparingArrays": "Bereite tempor√§re Arrays f√ºr die Zusammenf√ºhrung vor",
        "copyingLeft": "Kopiere linken Teil von Index {{start}} bis {{end}}",
        "copyingRight": "Kopiere rechten Teil von Index {{start}} bis {{end}}",
        "copyingElement": "Kopiere Element A[{{index}}]={{value}} nach {{array}}[{{targetIndex}}]",
        "removingElement": "Entferne Element aus dem Hauptarray an Position {{index}}",
        "mergingBack": "F√ºhre Elemente zur√ºck in das Hauptarray von Index {{start}} bis {{end}}",
        "comparing": "Vergleiche L[{{leftIndex}}]={{leftValue}} mit R[{{rightIndex}}]={{rightValue}}",
        "placingLeft": "Platziere L[{{index}}]={{value}} an Position {{position}}",
        "placingRight": "Platziere R[{{index}}]={{value}} an Position {{position}}",
        "placingRemaining": "Platziere verbleibendes {{array}}[{{index}}]={{value}} an Position {{position}}",
        "clearingArrays": "Leere tempor√§re Arrays",
        "updatingMainArray": "Aktualisiere Hauptarray mit sortierten Elementen",
        "sortingComplete": "Merge Sort erfolgreich abgeschlossen!"
      },
      "task": {
        "title": "Aufgabe 1: Schrittweise Array-Werte",
        "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays nach jedem Merge-Schritt ein.",
        "inputArray": "Eingabearray:",
        "submit": "Einreichen?"
      }
    },
    "quick": {
      "description": "QuickSort ist ein Teile-und-Herrsche-Algorithmus, der ein Pivot-Element ausw√§hlt und das Array um dieses herum partitioniert, wobei kleinere Elemente links und gr√∂√üere rechts platziert werden.",
      "process": "Prozess:",
      "steps": {
        "1": "W√§hle ein Pivot-Element aus dem Array",
        "2": "Partitioniere das Array um das Pivot-Element",
        "3": "Sortiere die Teilarrays links und rechts rekursiv",
        "4": "Kombiniere die sortierten Teilarrays"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(log n)",
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die Zeitkomplexit√§t von QuickSort im Durchschnittsfall?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Wie ist die Zeitkomplexit√§t von QuickSort im schlechtesten Fall?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(log n)"
            ],
            "correctAnswer": 0
          },
          {
            "question": "Welches Schl√ºsselkonzept verwendet QuickSort zum Sortieren des Arrays?",
            "answers": [
              "Zusammenf√ºhren sortierter Teilarrays",
              "Aufbau einer Heap-Struktur",
              "Partitionierung um ein Pivot-Element",
              "Z√§hlen von Elementh√§ufigkeiten"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Was verursacht den schlechtesten Fall bei QuickSort?",
            "answers": [
              "Zuf√§llige Daten",
              "Bereits sortierte Daten",
              "Wahl des kleinsten/gr√∂√üten Elements als Pivot",
              "Gro√üe Arrays"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Warum wird QuickSort in der Praxis oft bevorzugt?",
            "answers": [
              "Stabile Sortierung",
              "Gute Cache-Leistung und In-Place-Sortierung",
              "Vorhersagbare Leistung",
              "Geringer Speicherverbrauch"
            ],
            "correctAnswer": 1
          }
        ]
      },
      "task": {
        "title": "Aufgabe 1 Schrittweise A Wert der Partition",
        "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays A nach jeder Partition ein.",
        "inputArray": "Eingabearray:",
        "alreadyCompleted": "Sie haben diese Aufgabe bereits abgeschlossen und {{points}} Punkte erhalten!",
        "pointsEarned": "Gl√ºckwunsch! Sie haben {{points}} Punkte f√ºr diese Aufgabe erhalten!"
      }
    },
    "bucket": {
      "description": "Bucket Sort teilt die Eingabe in eine endliche Anzahl von Beh√§ltern (Buckets) auf, sortiert jeden Beh√§lter einzeln und verkettet sie dann zum endg√ºltig sortierten Array.",
      "process": "Prozess:",
      "steps": {
        "1": "Erstelle Beh√§lter und verteile Elemente",
        "2": "Sortiere Elemente innerhalb jedes Beh√§lters",
        "3": "F√ºhre alle Beh√§lter der Reihe nach zusammen",
        "4": "Kombiniere Elemente zum sortierten Array"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "Œ©(n+k)",
      "averageTime": "Œò(n+k)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(n+k)",
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die durchschnittliche Zeitkomplexit√§t von Bucket Sort?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "Œò(n+k)",
              "O(n)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Was ist die Hauptidee hinter Bucket Sort?",
            "answers": [
              "Verwendung eines Pivot-Elements",
              "Aufteilung in kleinere Beh√§lter und deren Sortierung",
              "Aufbau einer Heap-Struktur",
              "Z√§hlen von Elementh√§ufigkeiten"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Wann ist Bucket Sort am effizientesten?",
            "answers": [
              "Bei zuf√§lligen Verteilungen",
              "Bei gleichm√§√üiger Verteilung der Elemente",
              "Bei umgekehrt sortierten Arrays",
              "Bei bereits sortierten Arrays"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Welcher Faktor beeinflusst die Anzahl der ben√∂tigten Beh√§lter?",
            "answers": [
              "Nur die Array-Gr√∂√üe",
              "Datenverteilung und Wertebereich",
              "Verf√ºgbarer Speicher",
              "Verwendeter Sortieralgorithmus"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Was passiert, wenn alle Elemente in denselben Beh√§lter fallen?",
            "answers": [
              "Der Algorithmus schl√§gt fehl",
              "Die Leistung wird O(n)",
              "Die Leistung verschlechtert sich zu O(n¬≤)",
              "Zus√§tzliche Beh√§lter werden erstellt"
            ],
            "correctAnswer": 2
          }
        ]
      }
    }
  },
  "general": {
    "explanation": "^^^ Algo Erkl√§rung ^^^",
    "tipps": "^^^ Tipps ^^^",
    "quiz": {
      "title": "Teste dein Wissen",
      "next": "N√§chste Frage",
      "check": "Pr√ºfen",
      "finish": "Quiz beenden",
      "completed": "Quiz abgeschlossen!",
      "score": "{{correctTasks}}/{{totalTasks}} Aufgaben richtig",
      "points": "({{points}} Punkte erhalten)",
      "restart": "Nochmal versuchen"
    },
    "leaderboard": {
      "title": "Top 10 Bestenliste üèÜ",
      "rank": "Rang",
      "name": "Name",
      "score": "Punkte",
      "progress": "Fortschritt",
      "noData": "Noch keine Eintr√§ge"
    },
    "buttons": {
      "shuffle": "Mischen",
      "sort": "Sortieren",
      "step": "Schritt",
      "manual": "Manuell",
      "continue": "Fortsetzen",
      "pause": "Pause",
      "animate": "Animieren",
      "showPivot": "Pivot anzeigen",
      "hidePivot": "Pivot ausblenden"
    }
  },
  "comments": {
    "reply": "Antworten",
    "delete": "L√∂schen",
    "postReply": "Antwort senden",
    "postComment": "Kommentar senden",
    "charactersRemaining": "{{count}} Zeichen √ºbrig",
    "writePlaceholder": "Schreibe einen Kommentar...",
    "replyPlaceholder": "Schreibe eine Antwort..."
  }
}
