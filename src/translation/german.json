{
  "navigation": {
    "imprint": "Impressum",
    "home": "Startseite",
    "sorting": "Sortieralgorithmen",
    "search": "Suche",
    "graphs": "Graphen",
    "coding": "Coding",
    "account" : "Account",
    "radix": "Radix",
    "merge": "Merge",
    "bucket": "Bucket",
    "counting": "Counting",
    "heap": "Heap",
    "quick": "Quick",
    "insertion": "Insertion"
  },
  "home": {
    "title": "ALGO",
    "subtitle": "Willkommen zu den Aufgaben der Algorithmen!",
    "noLoginRequired": "Es ist nicht notwendig, sich anzumelden, um die √úbungen zu machen.",
    "bonusNote": "‚ö†Ô∏è Wenn Sie jedoch den Vorlesungsbonus erhalten m√∂chten, m√ºssen Sie sich anmelden und abgeschlossene Aufgaben einreichen.",
    "tipsTitle": "üí° Tipps:",
    "tipSubmit": "Vergessen Sie nach erfolgreichem Abschluss einer Aufgabe nicht, auf die Schaltfl√§che \"Absenden\" zu klicken! üîî",
    "tipBigScreen": "Es ist sch√∂ner, gro√üe Bildschirme zu verwenden ü§ì",
    "loginInstruction": "Verwenden Sie zur Anmeldung die Informationen, die Ihr Dozent Ihnen gegeben hat. üìú",
    "bonusInstruction": "Um den Bonus zu erhalten, schlie√üen Sie alle Aufgaben vor der Pr√ºfung ab!!! ‚è≥",
    "fun": "Viel Spa√ü! üéâ"
  },
  "sorting": {
    "insertion": {
      "description": "Insertion Sort baut ein sortiertes Array auf, indem es ein Element nach dem anderen vergleicht und an die richtige Position einf√ºgt, √§hnlich wie beim Sortieren von Spielkarten in der Hand.",
      "process": "Prozess:",
      "steps": {
        "1": "Beginne mit dem ersten Element als sortiert",
        "2": "Nimm das n√§chste Element und vergleiche es mit allen Elementen im sortierten Bereich",
        "3": "Verschiebe gr√∂√üere Elemente nach rechts, um Platz zu schaffen",
        "4": "F√ºge das Element an der richtigen Position ein",
        "5": "Wiederhole Schritte 2-4, bis alle Elemente sortiert sind"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "animation": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Mische!",
        "sortingCompleted": "Sortierung abgeschlossen!",
        "key": "A[{{index}}] = Schl√ºssel = {{value}}",
        "comparison": "A[{{index}}] = {{value}} ist {{comparison}} als der Schl√ºssel(={{key}})",
        "smaller": "kleiner",
        "greater": "gr√∂√üer",
        "propagating": "propagiere vorw√§rts...",
        "placingKey": "platziere den Schl√ºssel(={{key}}) bei A[{{index}}]",
        "nextKey": "weiter zum n√§chsten Schl√ºssel..."
      },
      "task": {
        "title": "Aufgabe 1 Schrittweise Wert",
        "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays A nach jeder for-Schleife ein.",
        "inputArray": "Eingabearray:",
        "submit": "Einreichen?"
      },
      "quiz": {
        "questions": [
          {
            "question": "Wie ist die Zeitkomplexit√§t von Insertion Sort im besten Fall?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Welche der folgenden Aussagen √ºber Insertion Sort ist richtig?",
            "answers": [
              "Es ben√∂tigt zus√§tzlichen Speicher proportional zur Eingabegr√∂√üe",
              "Es ist nicht geeignet f√ºr kleine Datenmengen",
              "Es funktioniert gut mit bereits sortierten Daten",
              "Es braucht immer die gleiche Zeit unabh√§ngig von der Eingabe"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Wie ist die Speicherkomplexit√§t von Insertion Sort?",
            "answers": [
              "O(n)",
              "O(log n)",
              "O(n¬≤)",
              "O(1)"
            ],
            "correctAnswer": 3
          }
        ]
      }
    },
    "animation": {
      "common": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Array wird gemischt...",
        "shufflingFinished": "Array gemischt! Bereit zum Sortieren.",
        "sortingComplete": "Sortierung abgeschlossen!",
        "speedSlider": "Animationsgeschwindigkeit",
        "buttons": {
          "shuffle": "Mischen",
          "sort": "Sortieren",
          "step": "Schritt",
          "manual": "Manuell",
          "continue": "Fortsetzen",
          "pause": "Pause",
          "animate": "Animieren"
        }
      }
    },
    "heap": {
      "description": "Heap Sort verwendet eine bin√§re Heap-Datenstruktur und sortiert Elemente durch wiederholtes Extrahieren des maximalen Elements und Neuaufbau des Heaps.",
      "process": "Prozess:",
      "steps": {
        "1": "Erstelle einen Max-Heap aus dem Eingabe-Array",
        "2": "Tausche die Wurzel (maximales Element) mit dem letzten Element des Heaps",
        "3": "Entferne das letzte Element aus dem Heap (f√ºge es zum sortierten Bereich hinzu)",
        "4": "Heapifiziere das Wurzelelement, um die Max-Heap-Eigenschaft zu erhalten",
        "5": "Wiederhole Schritte 2-4, bis der Heap leer ist"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(1)",
      "animation": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Mische!",
        "shufflingFinished": "Mischen beendet. Starte Sortierung!",
        "sortingComplete": "Sortierung abgeschlossen!",
        "outOfBounds": "au√üerhalb des Bereichs!",
        "noChildren": "hat keine Kinder",
        "lookingAtNode": "Betrachte Wert {{value}}",
        "comparingWithChildren": "Vergleiche Wert {{parentValue}} mit seinen Kindern",
        "swappingNodes": "Tausche Werte {{value1}} und {{value2}}",
        "heapified": "Teilbaum bei Wert {{value}} heapifiziert",
        "extractingMax": "Extrahiere maximales Element aus dem Heap",
        "placingExtracted": "Platziere Wert {{value}} in sortierter Position",
        "buttons": {
          "shuffle": "Mischen",
          "sort": "Sortieren",
          "step": "Schritt",
          "manual": "Manuell",
          "continue": "Fortsetzen",
          "pause": "Pause",
          "animate": "Animieren"
        }
      }
    },
    "counting": {
      "description": "Counting Sort ist ein nicht-vergleichender Sortieralgorithmus, der durch Z√§hlen der Vorkommen jedes Elements und deren Platzierung an der richtigen Position funktioniert.",
      "process": "Prozess:",
      "steps": {
        "1": "Finde den Wertebereich des Eingabe-Arrays",
        "2": "Erstelle ein Z√§hl-Array und z√§hle jedes Element",
        "3": "Modifiziere das Z√§hl-Array, um die tats√§chlichen Positionen zu enthalten",
        "4": "Baue das Ausgabe-Array auf",
        "5": "Kopiere das Ausgabe-Array zur√ºck in das urspr√ºngliche Array"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n+k)",
      "averageTime": "O(n+k)",
      "worstTime": "O(n+k)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "countingPhase": "Starte Z√§hlphase...",
        "step1": "Erstelle Z√§hl-Array...",
        "accessingValue": "Greife auf Wert bei Index {{index}} zu: {{value}}",
        "selectingArray": "W√§hle Z√§hl-Array bei Index {{index}}",
        "incrementingCount": "Erh√∂he Z√§hler bei Index {{index}} auf {{count}}",
        "summingTotals": "Berechne Summen im Z√§hl-Array...",
        "calculatingSum": "Berechne Summe bei Index {{index}} mit vorherigem Index {{prevIndex}}",
        "sumResult": "Summe bei Index {{index}} ist {{sum}}",
        "placingElements": "Platziere Elemente in sortierte Positionen...",
        "selectingElement": "W√§hle Element bei Index {{index}}",
        "selectingCount": "Pr√ºfe Z√§hler bei Index {{index}}",
        "selectingPosition": "Position gefunden bei Index {{index}}",
        "placingElement": "Verschiebe Element von Index {{sourceIndex}} zu Position {{targetIndex}}",
        "decrementingCount": "Verringere Z√§hler bei Index {{index}}",
        "done": "Fertig!",
        "sortingComplete": "Array sortiert!"
      },
      "task": {
        "title": "Aufgabe 1: Bestimmung der Z√§hl-Arrays",
        "description": "F√ºllen Sie die Z√§hl-Arrays aus und konstruieren Sie das sortierte Array Schritt f√ºr Schritt.",
        "inputArray": "Eingabe-Array:",
        "arrays": {
          "counting": "Z√§hl-Array",
          "accumulating": "Akkumulierendes Array",
          "sortable": "Sortierbares Array",
          "unsorted": "Unsortiertes Array"
        },
        "submit": "Einreichen"
      }
    },
    "radix": {
      "description": "Radix Sort ist ein nicht-vergleichender Sortieralgorithmus, der Zahlen sortiert, indem jede Ziffer von der am wenigsten signifikanten zur am meisten signifikanten verarbeitet wird.",
      "process": "Prozess:",
      "steps": {
        "1": "Beginne mit der rechten Ziffer",
        "2": "Sortiere Zahlen basierend auf der aktuellen Ziffer",
        "3": "Gehe zur n√§chsten Ziffer links",
        "4": "Wiederhole, bis alle Ziffern verarbeitet sind"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(nk)",
      "averageTime": "O(nk)",
      "worstTime": "O(nk)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "initialMessage": "Mischen, dann sortieren! :)",
        "shuffling": "Mische!",
        "shufflingFinished": "Mischen beendet. Starte Sortierung!",
        "sortingComplete": "Sortierung abgeschlossen!",
        "selectingDigit": "W√§hle Ziffer Nr. {{index}}",
        "sorting": "Sortiere([{{digits}}])",
        "finishedDigit": "Sortierung basierend auf Ziffer Nr.{{index}} abgeschlossen"
      },
      "task": {
        "numbers": {
          "title": "Aufgabe 1 Schrittweise A Wert, Zahlen",
          "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays A nach jeder for-Schleife ein.",
          "inputArray": "Eingabearray:"
        },
        "words": {
          "title": "Aufgabe 2 Schrittweise B Wert, W√∂rter",
          "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays B nach jeder for-Schleife ein.",
          "inputArray": "Eingabearray:"
        },
        "iteration": {
          "afterIteration": "Nach Iteration Nr",
          "reset": "Zur√ºck",
          "check": "Pr√ºfen"
        }
      }
    },
    "merge": {
      "description": "Merge Sort ist ein Divide-and-Conquer-Algorithmus, der das Array rekursiv in kleinere Teilarrays aufteilt, diese sortiert und dann wieder zusammenf√ºhrt.",
      "process": "Prozess:",
      "steps": {
        "1": "Teile das Array in zwei H√§lften",
        "2": "Sortiere die linke und rechte H√§lfte rekursiv",
        "3": "F√ºhre die sortierten H√§lften wieder zusammen",
        "4": "Fahre fort, bis das gesamte Array sortiert ist"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(n)",
      "animation": {
        "copyingElement": "Kopiere Element A[{{index}}]={{value}} nach {{array}}[{{targetIndex}}]",
        "removingElement": "Entferne Element aus dem Hauptarray an Position {{index}}",
        "preparingArrays": "Bereite tempor√§re Arrays f√ºr die Zusammenf√ºhrung vor",
        "clearingArrays": "Leere tempor√§re Arrays",
        "updatingMainArray": "Aktualisiere Hauptarray mit sortierten Elementen",
        "sortingComplete": "Merge Sort erfolgreich abgeschlossen!"
      },
      "task": {
        "title": "Aufgabe 1: Schrittweise Array-Werte",
        "description": "Geben Sie f√ºr das gegebene Eingabearray die Werte des Arrays nach jedem Merge-Schritt ein.",
        "inputArray": "Eingabearray:",
        "submit": "Einreichen?"
      }
    },
    "quick": {
      "description": "QuickSort ist ein Teile-und-Herrsche-Algorithmus, der ein Pivot-Element ausw√§hlt und das Array um dieses herum partitioniert, wobei kleinere Elemente links und gr√∂√üere rechts platziert werden.",
      "process": "Prozess:",
      "steps": {
        "1": "W√§hle ein Pivot-Element aus dem Array",
        "2": "Partitioniere das Array um das Pivot-Element",
        "3": "Sortiere die Teilarrays links und rechts rekursiv",
        "4": "Kombiniere die sortierten Teilarrays"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(log n)"
    },
    "bucket": {
      "description": "Bucket Sort teilt die Eingabe in eine endliche Anzahl von Beh√§ltern (Buckets) auf, sortiert jeden Beh√§lter einzeln und verkettet sie dann zum endg√ºltig sortierten Array.",
      "process": "Prozess:",
      "steps": {
        "1": "Erstelle Beh√§lter und verteile Elemente",
        "2": "Sortiere Elemente innerhalb jedes Beh√§lters",
        "3": "F√ºhre alle Beh√§lter der Reihe nach zusammen",
        "4": "Kombiniere Elemente zum sortierten Array"
      },
      "complexity": "Komplexit√§t:",
      "case": "Fall",
      "time": "Zeit",
      "best": "Beste",
      "average": "Durchschnitt",
      "worst": "Schlechteste",
      "space": "Speicher",
      "bestTime": "Œ©(n+k)",
      "averageTime": "Œò(n+k)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(n+k)"
    }
  },
  "general": {
    "explanation": "^^^ Erkl√§rung ^^^",
    "tipps": "^^^ Tipps ^^^",
    "quiz": {
      "title": "Teste dein Wissen",
      "next": "N√§chste Frage",
      "check": "Pr√ºfen",
      "finish": "Quiz beenden",
      "completed": "Quiz abgeschlossen!",
      "score": "Dein Ergebnis: {{score}}/{{total}}",
      "restart": "Nochmal versuchen"
    },
    "leaderboard": {
      "title": "Top 10 Bestenliste üèÜ",
      "rank": "Rang",
      "name": "Name",
      "score": "Punkte",
      "progress": "Fortschritt",
      "noData": "Noch keine Eintr√§ge"
    },
    "buttons": {
      "shuffle": "Mischen",
      "sort": "Sortieren",
      "step": "Schritt",
      "manual": "Manuell",
      "continue": "Fortsetzen",
      "pause": "Pause",
      "animate": "Animieren"
    }
  }
}
