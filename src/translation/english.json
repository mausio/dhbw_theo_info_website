{
  "navigation": {
    "imprint": "Imprint",
    "home": "Home",
    "sorting": "Sorting",
    "search": "search",
    "graphs": "graphs",
    "coding": "coding",
    "account" : "account",
    "radix": "Radix",
    "merge": "Merge",
    "bucket": "Bucket",
    "counting": "Counting",
    "heap": "Heap",
    "quick": "Quick",
    "insertion": "Insertion",
    "reset": "Reset Demo Progress",
    "radixSort": "Radix Sort - The digit-by-digit mastermind",
    "countingSort": "Counting Sort - The expert counter and organizer"
  },
  "home": {
    "title": "ALGO",
    "story": {
      "welcomeTitle": "Welcome to Your Algorithm Adventure! üöÄ",
      "meetAlex": "Hey there! I'm Alex - Your Algorithm Guide",
      "intro": "Hey there! üëã I'm Alex, a fellow student, and I'll be your guide through the exciting world of algorithms. Not long ago, I was just like you, puzzled by these concepts. But then I discovered that learning algorithms can be an amazing adventure, where each algorithm has its own unique superpower!",
      "exerciseInfo": "The best part? You can start this journey right away - no login required! However, if you want to earn the lecture bonus (and trust me, it's worth it! üåü), make sure to log in and submit your completed tasks.",
      "meetCharacters": "Let me introduce you to our algorithm heroes:",
      "quickSort": "Quick Sort - The speedster who divides and conquers",
      "mergeSort": "Merge Sort - The master of combining pieces perfectly",
      "heapSort": "Heap Sort - The organized librarian of data",
      "insertionSort": "Insertion Sort - The careful card dealer",
      "bucketSort": "Bucket Sort - The sorting hat of our algorithm world",
      "radixSort": "Radix Sort - The digit-by-digit mastermind",
      "countingSort": "Counting Sort - The expert counter and organizer",
      "importantNotes": "Before we begin our adventure, here are some quick tips from a fellow traveler:",
      "loginTip": "üìú To log in, just use the information from your lecturer",
      "examTip": "‚è≥ Complete all tasks before the exam to secure your bonus",
      "submitTip": "üîî Don't forget to click 'submit' after completing each task",
      "screenTip": "ü§ì Use a big screen for the best experience",
      "callToAction": "Ready to join me on this adventure? Each algorithm has its own story to tell, and together we'll unlock their secrets! Track your progress on the leaderboard above and earn your algorithm master badge! üèÜ",
      "funWish": "Let's make learning algorithms fun! üéâ"
    }
  },
  "sorting": {
    "insertion": {
      "description": "Insertion Sort builds a sorted array one item at a time by comparing and inserting each element into its correct position, similar to sorting playing cards in your hands.",
      "process": "Process:",
      "steps": {
        "1": "Start with first element as sorted",
        "2": "Take next element and compare it with all elements in the sorted portion",
        "3": "Shift larger elements to the right to make space",
        "4": "Insert the element in its correct position",
        "5": "Repeat steps 2-4 until all elements are sorted"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "sortingCompleted": "Sorting completed!",
        "key": "A[{{index}}] = key = {{value}}",
        "comparison": "A[{{index}}] = {{value}} is {{comparison}} than the key(={{key}})",
        "smaller": "smaller",
        "greater": "greater",
        "propagating": "propagating forward...",
        "placingKey": "placing the key(={{key}}) at A[{{index}}]",
        "nextKey": "moving on to the next key..."
      },
      "task": {
        "title": "Task 1 Step-wise value",
        "description": "Given the input array, fill in the values of array A after each for loop.",
        "inputArray": "Input array:",
        "submit": "Submit?",
        "alreadyCompleted": "You already did this task '{{taskName}}' and got rewarded {{points}} points!",
        "pointsEarned": "You earned {{points}} points for task '{{taskName}}'!",
        "tryAgain": "Try Again"
      },
      "quiz": {
        "questions": [
          {
            "question": "What is the time complexity of Insertion Sort in the best case?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Which of the following is true about Insertion Sort?",
            "answers": [
              "It requires additional space proportional to input size",
              "It is not suitable for small data sets",
              "It performs well with already sorted data",
              "It always takes the same time regardless of input"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What is the space complexity of Insertion Sort?",
            "answers": [
              "O(n)",
              "O(log n)",
              "O(n¬≤)",
              "O(1)"
            ],
            "correctAnswer": 3
          },
          {
            "question": "What makes Insertion Sort efficient for small data sets?",
            "answers": [
              "It uses complex data structures",
              "It has simple implementation and low overhead",
              "It requires additional memory",
              "It uses recursion"
            ],
            "correctAnswer": 1
          },
          {
            "question": "How does Insertion Sort perform on nearly sorted arrays?",
            "answers": [
              "Poorly, requires many swaps",
              "Same as random data",
              "Very efficiently, approaches O(n)",
              "No difference from worst case"
            ],
            "correctAnswer": 2
          }
        ]
      }
    },
    "animation": {
      "common": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling array...",
        "shufflingFinished": "Array shuffled! Ready to sort.",
        "sortingComplete": "Sorting complete!",
        "speedSlider": "Animation Speed",
        "buttons": {
          "shuffle": "Shuffle",
          "sort": "Sort",
          "step": "Step",
          "manual": "Manual",
          "continue": "Continue",
          "pause": "Pause",
          "animate": "Animate"
        }
      }
    },
    "heap": {
      "description": "Heap Sort uses a binary heap data structure to sort elements by repeatedly extracting the maximum element and rebuilding the heap.",
      "process": "Process:",
      "steps": {
        "1": "Build a max heap from the input array",
        "2": "Swap the root (maximum element) with the last element of the heap",
        "3": "Remove the last element from the heap (add it to the sorted section)",
        "4": "Heapify the root element to maintain the max heap property",
        "5": "Repeat steps 2-4 until the heap is empty"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(1)",
      "quiz": {
        "questions": [
          {
            "question": "What is the time complexity of Heap Sort in all cases (best, average, and worst)?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What data structure is used in Heap Sort?",
            "answers": [
              "Linked List",
              "Stack",
              "Binary Heap",
              "Hash Table"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What is the space complexity of Heap Sort?",
            "answers": [
              "O(n)",
              "O(log n)",
              "O(n¬≤)",
              "O(1)"
            ],
            "correctAnswer": 3
          },
          {
            "question": "What property must be maintained in a max heap?",
            "answers": [
              "Parent nodes are smaller than children",
              "All levels must be complete",
              "Parent nodes are greater than children",
              "Nodes must be balanced"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Is Heap Sort stable?",
            "answers": [
              "Yes, always",
              "No, it can change the relative order of equal elements",
              "Depends on implementation",
              "Only for small arrays"
            ],
            "correctAnswer": 1
          }
        ]
      },
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "shufflingFinished": "Shuffling finished. Start sorting!",
        "sortingComplete": "Sorting complete!",
        "outOfBounds": "out of bounds!",
        "noChildren": "has no children",
        "lookingAtNode": "Looking at value {{value}}",
        "comparingWithChildren": "Comparing value {{parentValue}} with its children",
        "swappingNodes": "Swapping values {{value1}} and {{value2}}",
        "heapified": "Heapified subtree at value {{value}}",
        "extractingMax": "Extracting maximum element from heap",
        "placingExtracted": "Placing value {{value}} in sorted position",
        "buttons": {
          "shuffle": "Shuffle",
          "sort": "Sort",
          "step": "Step",
          "manual": "Manual",
          "continue": "Continue",
          "pause": "Pause",
          "animate": "Animate"
        }
      }
    },
    "counting": {
      "description": "Counting Sort is a non-comparative sorting algorithm that works by counting the occurrences of each element and placing them in their correct positions.",
      "process": "Process:",
      "steps": {
        "1": "Find the range of input array",
        "2": "Create a counting array and count occurrences",
        "3": "Modify counting array to store actual positions",
        "4": "Build output array using counting array",
        "5": "Copy output array back to original array"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n+k)",
      "averageTime": "O(n+k)",
      "worstTime": "O(n+k)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "countingPhase": "Starting counting phase...",
        "step1": "Creating counting array...",
        "accessingValue": "Accessing value at index {{index}}: {{value}}",
        "selectingArray": "Selecting counting array at index {{index}}",
        "incrementingCount": "Incrementing count at index {{index}} to {{count}}",
        "summingTotals": "Summing totals in counting array...",
        "calculatingSum": "Calculating sum at index {{index}} using previous index {{prevIndex}}",
        "sumResult": "Sum at index {{index}} is {{sum}}",
        "placingElements": "Placing elements in sorted positions...",
        "selectingElement": "Selecting element at index {{index}}",
        "selectingCount": "Looking up count at index {{index}}",
        "selectingPosition": "Found position at index {{index}}",
        "placingElement": "Moving element from index {{sourceIndex}} to position {{targetIndex}}",
        "decrementingCount": "Decrementing count at index {{index}}",
        "done": "Done!",
        "sortingComplete": "Array sorted!"
      },
      "task": {
        "title": "Task 1: Determination of Counting Arrays",
        "description": "Fill in the counting arrays and construct the sorted array step by step.",
        "inputArray": "Input array:",
        "arrays": {
          "counting": "Counting Array",
          "accumulating": "Accumulating Array",
          "sortable": "Sortable Array",
          "unsorted": "Unsorted Array"
        },
        "submit": "Submit",
        "alreadyCompleted": "You have already completed {{task}} and earned {{points}} points!",
        "pointsEarned": "Congratulations! You completed {{task}} and earned {{points}} points!"
      },
      "quiz": {
        "questions": [
          {
            "question": "What is the time complexity of Counting Sort?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n+k)",
              "O(n)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What is a limitation of Counting Sort?",
            "answers": [
              "Can only sort positive integers",
              "Requires a lot of memory for large ranges",
              "Only works on sorted arrays",
              "Cannot handle duplicates"
            ],
            "correctAnswer": 1
          },
          {
            "question": "Is Counting Sort a comparison-based sorting algorithm?",
            "answers": [
              "Yes, it compares elements directly",
              "No, it uses counting of elements",
              "Sometimes, depends on input",
              "Yes, but only for small arrays"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What makes Counting Sort efficient for integers?",
            "answers": [
              "It uses comparisons efficiently",
              "It uses divide and conquer",
              "It counts occurrences instead of comparing",
              "It uses a binary tree"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What determines the extra space needed in Counting Sort?",
            "answers": [
              "The size of input array",
              "The range of input values (k)",
              "The number of unique elements",
              "The sorting order"
            ],
            "correctAnswer": 1
          }
        ]
      }
    },
    "radix": {
      "description": "Radix Sort is a non-comparative sorting algorithm that sorts numbers by processing each digit position, starting from the least significant digit to the most significant digit.",
      "process": "Process:",
      "steps": {
        "1": "Start with the rightmost digit",
        "2": "Sort numbers based on the current digit",
        "3": "Move to the next digit to the left",
        "4": "Repeat until all digits are processed"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(nk)",
      "averageTime": "O(nk)",
      "worstTime": "O(nk)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "shufflingFinished": "Shuffling finished. Start sorting!",
        "sortingComplete": "Sorting complete!",
        "selectingDigit": "Selecting digit Nr. {{index}}",
        "sorting": "Sorting([{{digits}}])",
        "finishedDigit": "Finished sorting based on digit Nr.{{index}}"
      },
      "task": {
        "numbers": {
          "title": "Task 1 Step-wise A value, numbers",
          "description": "Given the input array, fill in the values of array A after each for loop.",
          "inputArray": "Input array:",
          "alreadyCompleted": "You have already completed {{task}} and earned {{points}} points!",
          "pointsEarned": "Congratulations! You completed {{task}} and earned {{points}} points!"
        },
        "words": {
          "title": "Task 2 Step-wise B value, words",
          "description": "Given the input array, fill in the values of array B after each for loop.",
          "inputArray": "Input array:",
          "alreadyCompleted": "You have already completed {{task}} and earned {{points}} points!",
          "pointsEarned": "Congratulations! You completed {{task}} and earned {{points}} points!"
        },
        "iteration": {
          "afterIteration": "After Iteration Nr",
          "reset": "Reset",
          "check": "Check"
        }
      },
      "quiz": {
        "questions": [
          {
            "question": "What is the time complexity of Radix Sort?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(nk)",
              "O(n+k)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What distinguishes Radix Sort from comparison-based sorting algorithms?",
            "answers": [
              "It uses a pivot element",
              "It doesn't compare elements directly",
              "It uses a heap structure",
              "It requires sorted input"
            ],
            "correctAnswer": 1
          },
          {
            "question": "In which order does Radix Sort process digits?",
            "answers": [
              "Most significant to least significant",
              "Least significant to most significant",
              "Random order",
              "Middle to ends"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What type of stability is crucial for Radix Sort to work correctly?",
            "answers": [
              "Memory stability",
              "Sort stability",
              "Time stability",
              "Space stability"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What determines the number of passes in Radix Sort?",
            "answers": [
              "Array size",
              "Number of unique elements",
              "Number of digits in largest number",
              "Memory constraints"
            ],
            "correctAnswer": 2
          }
        ]
      }
    },
    "merge": {
      "description": "Merge Sort is a divide-and-conquer algorithm that recursively divides the array into smaller subarrays, sorts them, and then merges them back together.",
      "process": "Process:",
      "steps": {
        "1": "Divide the array into two halves",
        "2": "Recursively sort the left and right halves",
        "3": "Merge the sorted halves back together",
        "4": "Continue until the entire array is sorted"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(n)",
      "quiz": {
        "questions": [
          {
            "question": "What is the time complexity of Merge Sort in all cases (best, average, and worst)?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What is the space complexity of Merge Sort?",
            "answers": [
              "O(n)",
              "O(log n)",
              "O(n¬≤)",
              "O(1)"
            ],
            "correctAnswer": 0
          },
          {
            "question": "Which algorithmic paradigm does Merge Sort use?",
            "answers": [
              "Greedy Algorithm",
              "Dynamic Programming",
              "Divide and Conquer",
              "Backtracking"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What is a key advantage of Merge Sort?",
            "answers": [
              "In-place sorting",
              "Low memory usage",
              "Guaranteed O(n log n) performance",
              "Simple implementation"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What is a disadvantage of Merge Sort?",
            "answers": [
              "High time complexity",
              "Requires extra space O(n)",
              "Not stable",
              "Cannot handle large datasets"
            ],
            "correctAnswer": 1
          }
        ]
      },
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "shufflingFinished": "Shuffling finished. Start sorting!",
        "sortingComplete": "Sorting complete!",
        "outOfBounds": "out of bounce!",
        "noChildren": "has no children",
        "buttons": {
          "shuffle": "Shuffle",
          "sort": "Sort",
          "step": "Step",
          "manual": "Manual",
          "continue": "Continue",
          "pause": "Pause",
          "animate": "Animate"
        },
        "lookingAtRange": "Looking at range from index {{start}} to {{end}}",
        "findingMiddle": "Finding middle point at index {{middle}}",
        "dividing": "Dividing array into left part ({{leftStart}}-{{leftEnd}}) and right part ({{rightStart}}-{{rightEnd}})",
        "sortingLeft": "Sorting left part from index {{start}} to {{end}}",
        "sortingRight": "Sorting right part from index {{start}} to {{end}}",
        "mergingRanges": "Merging ranges from {{leftStart}}-{{leftEnd}} and {{rightStart}}-{{rightEnd}}",
        "preparingArrays": "Preparing temporary arrays for merging",
        "copyingLeft": "Copying left part from index {{start}} to {{end}}",
        "copyingRight": "Copying right part from index {{start}} to {{end}}",
        "copyingElement": "Copying element A[{{index}}]={{value}} to {{array}}[{{targetIndex}}]",
        "removingElement": "Removing element from main array at position {{index}}",
        "mergingBack": "Merging elements back into main array from index {{start}} to {{end}}",
        "comparing": "Comparing L[{{leftIndex}}]={{leftValue}} with R[{{rightIndex}}]={{rightValue}}",
        "placingLeft": "Placing L[{{index}}]={{value}} at position {{position}}",
        "placingRight": "Placing R[{{index}}]={{value}} at position {{position}}",
        "placingRemaining": "Placing remaining {{array}}[{{index}}]={{value}} at position {{position}}",
        "clearingArrays": "Clearing temporary arrays",
        "updatingMainArray": "Updating main array with sorted elements",
        "sortingComplete": "Merge Sort successfully completed!"
      },
      "task": {
        "title": "Task 1: Step-wise Array Values",
        "description": "Given the input array, fill in the values of the array after each merge step.",
        "inputArray": "Input array:",
        "submit": "Submit?"
      }
    },
    "quick": {
      "description": "QuickSort is a divide-and-conquer algorithm that works by selecting a pivot element and partitioning the array around it, with smaller elements on the left and larger ones on the right.",
      "process": "Process:",
      "steps": {
        "1": "Choose a pivot element from the array",
        "2": "Partition the array around the pivot",
        "3": "Recursively sort the sub-arrays on left and right",
        "4": "Combine the sorted sub-arrays"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(log n)",
      "quiz": {
        "questions": [
          {
            "question": "What is the time complexity of QuickSort in the average case?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(1)"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What is the worst-case time complexity of QuickSort?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "O(n)",
              "O(log n)"
            ],
            "correctAnswer": 0
          },
          {
            "question": "What is the key concept that QuickSort uses to sort the array?",
            "answers": [
              "Merging sorted subarrays",
              "Building a heap structure",
              "Partitioning around a pivot",
              "Counting element frequencies"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What causes QuickSort's worst-case scenario?",
            "answers": [
              "Random data",
              "Already sorted data",
              "Choosing smallest/largest element as pivot",
              "Large arrays"
            ],
            "correctAnswer": 2
          },
          {
            "question": "Why is QuickSort often preferred in practice?",
            "answers": [
              "Stable sorting",
              "Good cache performance and in-place sorting",
              "Predictable performance",
              "Low memory usage"
            ],
            "correctAnswer": 1
          }
        ]
      },
      "task": {
        "title": "Task 1 Step-wise A value of partition",
        "description": "Given the input array, fill in the values of array A after each partition",
        "inputArray": "Input array:",
        "alreadyCompleted": "You have already completed {{task}} and earned {{points}} points!",
        "pointsEarned": "Congratulations! You completed {{task}} and earned {{points}} points!"
      }
    },
    "bucket": {
      "description": "Bucket Sort divides the input into a finite number of buckets, sorts each bucket individually, and then concatenates them to get the final sorted array.",
      "process": "Process:",
      "steps": {
        "1": "Create buckets and distribute elements",
        "2": "Sort elements within each bucket",
        "3": "Merge all buckets in order",
        "4": "Combine elements to form sorted array"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "Œ©(n+k)",
      "averageTime": "Œò(n+k)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(n+k)",
      "quiz": {
        "questions": [
          {
            "question": "What is the average time complexity of Bucket Sort?",
            "answers": [
              "O(n¬≤)",
              "O(n log n)",
              "Œò(n+k)",
              "O(n)"
            ],
            "correctAnswer": 2
          },
          {
            "question": "What is the main idea behind Bucket Sort?",
            "answers": [
              "Using a pivot element",
              "Dividing into smaller buckets and sorting them",
              "Building a heap structure",
              "Counting element frequencies"
            ],
            "correctAnswer": 1
          },
          {
            "question": "When is Bucket Sort most efficient?",
            "answers": [
              "With random distributions",
              "With uniform distribution of elements",
              "With reverse sorted arrays",
              "With already sorted arrays"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What factor affects the number of buckets needed?",
            "answers": [
              "Array size only",
              "Data distribution and range",
              "Available memory",
              "Sorting algorithm used"
            ],
            "correctAnswer": 1
          },
          {
            "question": "What happens if all elements fall into the same bucket?",
            "answers": [
              "The algorithm fails",
              "Performance becomes O(n)",
              "Performance degrades to O(n¬≤)",
              "Extra buckets are created"
            ],
            "correctAnswer": 2
          }
        ]
      }
    }
  },
  "general": {
    "explanation": "^^^ Algo Explanation ^^^",
    "tipps": "^^^ Tipps ^^^",
    "quiz": {
      "title": "Test Your Knowledge",
      "next": "Next Question",
      "check": "Check",
      "finish": "Finish Quiz",
      "completed": "Quiz Completed!",
      "score": "{{correctTasks}}/{{totalTasks}} tasks correct",
      "points": "({{points}} points rewarded)",
      "restart": "Try Again"
    },
    "leaderboard": {
      "title": "Top 10 Leaderboard üèÜ",
      "rank": "Rank",
      "name": "Name",
      "score": "Score",
      "progress": "Progress",
      "noData": "No entries yet"
    },
    "buttons": {
      "shuffle": "Shuffle",
      "sort": "Sort",
      "step": "Step",
      "manual": "Manual",
      "continue": "Continue",
      "pause": "Pause",
      "animate": "Animate",
      "showPivot": "Show Pivot",
      "hidePivot": "Hide Pivot"
    }
  },
  "comments": {
    "reply": "Reply",
    "delete": "Delete",
    "postReply": "Post Reply",
    "postComment": "Post Comment",
    "charactersRemaining": "{{count}} characters remaining",
    "writePlaceholder": "Write a comment...",
    "replyPlaceholder": "Write a reply..."
  }
}
