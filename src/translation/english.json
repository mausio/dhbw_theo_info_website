{
  "navigation": {
    "imprint": "Imprint",
    "home": "Home",
    "sorting": "Sorting",
    "search": "search",
    "graphs": "graphs",
    "coding": "coding",
    "account" : "account",
    "radix": "Radix",
    "merge": "Merge",
    "bucket": "Bucket",
    "counting": "Counting",
    "heap": "Heap",
    "quick": "Quick",
    "insertion": "Insertion"
  },
  "home": {
    "title": "ALGO",
    "subtitle": "Welcome to the exercises of algorithms!",
    "noLoginRequired": "It is not necessary to log in in order to do the exercises.",
    "bonusNote": "‚ö†Ô∏è However, if you would like to gain the lecture bonus, you must log in and submit completed tasks.",
    "tipsTitle": "üí° Tipps:",
    "tipSubmit": "After completing a task successfully, don't forget to click the submit button! üîî",
    "tipBigScreen": "It is nicer to use big screens ü§ì",
    "loginInstruction": "To log in, use the information given by your lecturer. üìú",
    "bonusInstruction": "To gain the bonus, complete all the tasks before the exam!!! ‚è≥",
    "fun": "Have fun! üéâ"
  },
  "sorting": {
    "insertion": {
      "description": "Insertion Sort builds a sorted array one item at a time by comparing and inserting each element into its correct position, similar to sorting playing cards in your hands.",
      "process": "Process:",
      "steps": {
        "1": "Start with first element as sorted",
        "2": "Take next element and compare it with all elements in the sorted portion",
        "3": "Shift larger elements to the right to make space",
        "4": "Insert the element in its correct position",
        "5": "Repeat steps 2-4 until all elements are sorted"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "sortingCompleted": "Sorting completed!",
        "key": "A[{{index}}] = key = {{value}}",
        "comparison": "A[{{index}}] = {{value}} is {{comparison}} than the key(={{key}})",
        "smaller": "smaller",
        "greater": "greater",
        "propagating": "propagating forward...",
        "placingKey": "placing the key(={{key}}) at A[{{index}}]",
        "nextKey": "moving on to the next key..."
      },
      "task": {
        "title": "Task 1 Step-wise value",
        "description": "Given the input array, fill in the values of array A after each for loop.",
        "inputArray": "Input array:",
        "submit": "Submit?"
      }
    },
    "animation": {
      "common": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling array...",
        "shufflingFinished": "Array shuffled! Ready to sort.",
        "sortingComplete": "Sorting complete!",
        "speedSlider": "Animation Speed",
        "buttons": {
          "shuffle": "Shuffle",
          "sort": "Sort",
          "step": "Step",
          "manual": "Manual",
          "continue": "Continue",
          "pause": "Pause",
          "animate": "Animate"
        }
      }
    },
    "heap": {
      "description": "Heap Sort uses a binary heap data structure to sort elements by repeatedly extracting the maximum element and rebuilding the heap.",
      "process": "Process:",
      "steps": {
        "1": "Build a max heap from the input array",
        "2": "Swap the root (maximum element) with the last element of the heap",
        "3": "Remove the last element from the heap (add it to the sorted section)",
        "4": "Heapify the root element to maintain the max heap property",
        "5": "Repeat steps 2-4 until the heap is empty"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(1)",
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "shufflingFinished": "Shuffling finished. Start sorting!",
        "sortingComplete": "Sorting complete!",
        "outOfBounds": "out of bounds!",
        "noChildren": "has no children",
        "lookingAtNode": "Looking at value {{value}}",
        "comparingWithChildren": "Comparing value {{parentValue}} with its children",
        "swappingNodes": "Swapping values {{value1}} and {{value2}}",
        "heapified": "Heapified subtree at value {{value}}",
        "extractingMax": "Extracting maximum element from heap",
        "placingExtracted": "Placing value {{value}} in sorted position",
        "buttons": {
          "shuffle": "Shuffle",
          "sort": "Sort",
          "step": "Step",
          "manual": "Manual",
          "continue": "Continue",
          "pause": "Pause",
          "animate": "Animate"
        }
      }
    },
    "counting": {
      "description": "Counting Sort is a non-comparative sorting algorithm that works by counting the occurrences of each element and placing them in their correct positions.",
      "process": "Process:",
      "steps": {
        "1": "Find the range of input array",
        "2": "Create a counting array and count occurrences",
        "3": "Modify counting array to store actual positions",
        "4": "Build output array using counting array",
        "5": "Copy output array back to original array"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n+k)",
      "averageTime": "O(n+k)",
      "worstTime": "O(n+k)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "countingPhase": "Starting counting phase...",
        "step1": "Creating counting array...",
        "accessingValue": "Accessing value at index {{index}}: {{value}}",
        "selectingArray": "Selecting counting array at index {{index}}",
        "incrementingCount": "Incrementing count at index {{index}} to {{count}}",
        "summingTotals": "Summing totals in counting array...",
        "calculatingSum": "Calculating sum at index {{index}} using previous index {{prevIndex}}",
        "sumResult": "Sum at index {{index}} is {{sum}}",
        "placingElements": "Placing elements in sorted positions...",
        "selectingElement": "Selecting element at index {{index}}",
        "selectingCount": "Looking up count at index {{index}}",
        "selectingPosition": "Found position at index {{index}}",
        "placingElement": "Moving element from index {{sourceIndex}} to position {{targetIndex}}",
        "decrementingCount": "Decrementing count at index {{index}}",
        "done": "Done!",
        "sortingComplete": "Array sorted!"
      },
      "task": {
        "title": "Task 1: Determination of counting arrays",
        "description": "Fill in the counting arrays and construct the sorted array step by step.",
        "inputArray": "Input array:",
        "arrays": {
          "counting": "Counting Array",
          "accumulating": "Accumulating Array",
          "sortable": "Sortable Array",
          "unsorted": "Unsorted Array"
        },
        "submit": "Submit"
      }
    },
    "radix": {
      "description": "Radix Sort is a non-comparative sorting algorithm that sorts numbers by processing each digit position, starting from the least significant digit to the most significant digit.",
      "process": "Process:",
      "steps": {
        "1": "Start with the rightmost digit",
        "2": "Sort numbers based on the current digit",
        "3": "Move to the next digit to the left",
        "4": "Repeat until all digits are processed"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(nk)",
      "averageTime": "O(nk)",
      "worstTime": "O(nk)",
      "spaceComplexity": "O(n+k)",
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "shufflingFinished": "Shuffling finished. Start sorting!",
        "sortingComplete": "Sorting complete!",
        "selectingDigit": "Selecting digit Nr. {{index}}",
        "sorting": "Sorting([{{digits}}])",
        "finishedDigit": "Finished sorting based on digit Nr.{{index}}"
      },
      "task": {
        "numbers": {
          "title": "Task 1 Step-wise A value, numbers",
          "description": "Given the input array, fill in the values of array A after each for loop.",
          "inputArray": "Input array:"
        },
        "words": {
          "title": "Task 2 Step-wise B value, words",
          "description": "Given the input array, fill in the values of array B after each for loop.",
          "inputArray": "Input array:"
        },
        "iteration": {
          "afterIteration": "After Iteration Nr",
          "reset": "Reset",
          "check": "Check"
        }
      }
    },
    "merge": {
      "description": "Merge Sort is a divide-and-conquer algorithm that recursively divides the array into smaller subarrays, sorts them, and then merges them back together.",
      "process": "Process:",
      "steps": {
        "1": "Divide the array into two halves",
        "2": "Recursively sort the left and right halves",
        "3": "Merge the sorted halves back together",
        "4": "Continue until the entire array is sorted"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n log n)",
      "spaceComplexity": "O(n)",
      "animation": {
        "initialMessage": "shuffle, then sort! :)",
        "shuffling": "Shuffling!",
        "shufflingFinished": "Shuffling finished. Start sorting!",
        "sortingComplete": "Sorting complete!",
        "outOfBounds": "out of bounce!",
        "noChildren": "has no children",
        "buttons": {
          "shuffle": "Shuffle",
          "sort": "Sort",
          "step": "Step",
          "manual": "Manual",
          "continue": "Continue",
          "pause": "Pause",
          "animate": "Animate"
        }
      }
    },
    "quick": {
      "description": "QuickSort is a divide-and-conquer algorithm that works by selecting a pivot element and partitioning the array around it, with smaller elements on the left and larger ones on the right.",
      "process": "Process:",
      "steps": {
        "1": "Choose a pivot element from the array",
        "2": "Partition the array around the pivot",
        "3": "Recursively sort the sub-arrays on left and right",
        "4": "Combine the sorted sub-arrays"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "O(n log n)",
      "averageTime": "O(n log n)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(log n)"
    },
    "bucket": {
      "description": "Bucket Sort divides the input into a finite number of buckets, sorts each bucket individually, and then concatenates them to get the final sorted array.",
      "process": "Process:",
      "steps": {
        "1": "Create buckets and distribute elements",
        "2": "Sort elements within each bucket",
        "3": "Merge all buckets in order",
        "4": "Combine elements to form sorted array"
      },
      "complexity": "Complexity:",
      "case": "Case",
      "time": "Time",
      "best": "Best",
      "average": "Average",
      "worst": "Worst",
      "space": "Space",
      "bestTime": "Œ©(n+k)",
      "averageTime": "Œò(n+k)",
      "worstTime": "O(n¬≤)",
      "spaceComplexity": "O(n+k)"
    }
  },
  "general": {
    "explanation": "^^^ Explanation ^^^",
    "tipps": "^^^ Tipps ^^^",
    "leaderboard": {
      "title": "Top 10 Leaderboard üèÜ",
      "rank": "Rank",
      "name": "Name",
      "score": "Score",
      "progress": "Progress",
      "noData": "No entries yet"
    },
    "buttons": {
      "shuffle": "Shuffle",
      "sort": "Sort",
      "step": "Step",
      "manual": "Manual",
      "continue": "Continue",
      "pause": "Pause",
      "animate": "Animate"
    }
  }
}
